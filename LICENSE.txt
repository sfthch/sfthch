The MIT License (MIT)

Copyright (c) 2019 Samarjeet

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


@if exist %1.sql mysql --defaults-extra-file=mylogin_hchla.cnf maas -t -v -v --force < %1.sql > %1.log

[client]
host=192.168.0.60
port=3306
user=adm_maas
password=!Devadm33%

SET @ver_id = 'NV_SJA_0000002';

SET  profiling=1;

-- EXPLAIN FORMAT = TREE /*
 EXPLAIN -- ANALYZE -- PARTITIONS -- */
;

SHOW WARNINGS \G;

FLUSH STATUS;

-- EXPLAIN FORMAT = TREE /*
 EXPLAIN  ANALYZE -- PARTITIONS -- */
;

SHOW STATUS LIKE 'Sort%';
SHOW SESSION STATUS LIKE 'Created_tmp%';
SHOW SESSION STATUS LIKE 'handler_read%';

#SHOW profiles;
SELECT IFNULL(SUM(duration), 0.000000) AS executing
  FROM information_schema.profiling
 WHERE query_id = 4
   AND state IN ('executing', 'Sending data')
;
SELECT SUM(duration) AS duration
  FROM information_schema.profiling
 WHERE query_id = 4
;
#SHOW profile for query 4;

SET  profiling=0;

SELECT /*+  */
       SQL_CALC_FOUND_ROWS
 ORDER BY RAND()
 LIMIT 10
;

SELECT FOUND_ROWS();


# +----------------+------------------------------------------------------------------+-----------+  +----------------------+----------+
# | 힌트 이름      | 설명                                                             | 영향 범위 |  | Status               | Duration |
# +----------------+------------------------------------------------------------------+-----------+  +----------------------+----------+
# | INDEX,         | GROUP BY, ORDER BY, WHERE 절의 처리를 위한 인덱스 사용 여부 제어 | 인덱스    |  | starting             | 0.000037 | (시작)
# | NO_INDEX       |                                                                  |           |  | checking permissions | 0.000005 | (사용권한확인)
# +----------------+------------------------------------------------------------------+-----------+  | Opening tables       | 0.000012 | (테이블열기)
# | GROUP_INDEX,   | GROUP BY 절의 처리를 위한 인덱스 사용 여부 제어                  | 인덱스    |  | After opening tables | 0.000007 | (테이블을 연 후에)
# | NO_GROUP_INDEX |                                                                  |           |  | System lock          | 0.000004 | (시스템잠금)
# +----------------+------------------------------------------------------------------+-----------+  | Table lock           | 0.000006 | (테이블잠금)
# | JOIN_INDEX,    | WHERE 절의 처리를 위한 인덱스 사용 여부 제어                     | 인덱스    |  | init                 | 0.000018 | (초기화)
# | NO_JOIN_INDEX  |                                                                  |           |  | optimizing           | 0.000007 | (최적화)
# +----------------+------------------------------------------------------------------+-----------+  | statistics           | 0.000010 | (통계)
# | ORDER_INDEX,   | ORDER BY 절의 처리를 위한 인덱스 사용 여부 제어                  | 인덱스    |  | preparing            | 0.000014 | (준비)
# | NO_ORDER_INDEX |                                                                  |           |  | executing            | 0.000004 | (실행)
# +----------------+------------------------------------------------------------------+-----------+  | Sending data         | 0.212919 | (데이터보내기)
# +---------------------------+-----------------+                                                    | end                  | 0.000010 | (끝)
# | 인덱스 힌트               | 옵티마이저 힌트 |                                                    | query end            | 0.000009 | (질의끝)
# +---------------------------+-----------------+                                                    | closing tables       | 0.000005 | (테이블닫기)
# | USE INDEX                 | INDEX           |                                                    | Unlocking tables     | 0.000012 | (잠금해제테이블)
# | USE INDEX FOR GROUP BY    | GROUP_INDEX     |                                                    | freeing items        | 0.000006 | (항목해방)
# | USE INDEX FOR ORDER BY    | ORDER_INDEX     |                                                    | updating status      | 0.000029 | (상태업데이트)
# | IGNORE INDEX              | NO_INDEX        |                                                    | cleaning up          | 0.000003 | (청소)
# | IGNORE INDEX FOR GROUP BY | NO_GROUP_INDEX  |                                                    +----------------------+----------+
# | IGNORE INDEX FOR ORDER BY | NO_ORDER_INDEX  |
# +---------------------------+-----------------+
#
# 각각의 구체적인 Handler 의 내용은 다음과 같습니다.
#
# Handler_read_first    : 첫 번째 엔트리가 인덱스에서 읽혀진 횟수.
#                         이 값이 크다면, 서버는 많은 수의 전체 인덱스 스캔 (full index scan)을 실행하고 있음을 의미하는 것이다;
#                         예를 들면, SELECT col1 FROM foo의 경우에서 col1은 인덱스 된 것으로 간주된다.
# Handler_read_key      : 키를 근거로 열을 읽기 위한 요청 횟수.
#                         이 값이 크다면, 여러분이 사용하는 테이블이 쿼리에 올바르게 인덱스 되어 있다는 좋은 의미다.
# Handler_read_next     : 키 순서에서 바로 다음에 있는 열을 읽기 위한 요청 횟수.
#                         인덱스 컬럼을 범위 제한 값으로 쿼리 하거나 또는 인덱스 스캔을 한다면, 이 값이 증가하게 된다.
# Handler_read_prev     : 키 순서에서 바로 전에 있는 열을 읽기 위한 요청 횟수.
#                         이러한 읽기 방식은 주로 ORDER BY ... DESC를 최적화 시키기 위해 사용된다.
# Handler_read_rnd      : 고정된 위치를 근거로 열을 읽기 위한 요청 횟수.
#                         결과 값을 정렬하도록 요청하는 많은 수의 쿼리를 실행하는 중이라면, 이 값이 높게 설정된다.
#                         이것은 MySQL이 전체 테이블을 스캔할 것을 요구하는쿼리를 많이 가지고 있거나
#                         또는 키를 정확히 사용하지 않는 조인(join)을 가지고 있는 것이다.
# Handler_read_rnd_next : 데이터 파일에 있는 다음 열을 읽기 위한 요청 횟수.
#                         이 값은 여러분이 많은 수의 테이블 스캔을 할 경우에 높게 된다.
#                         이것은 일반적으로 테이블이 올바르게 인덱스 되지 않았거나
#                         또는 쿼리가 인덱스를 제대로 활용하지 못하고 있음을 의미한다.


SELECT ROW_NUMBER ( ) OVER ( ORDER BY a.table_schema
                                    , a.table_name
                                    , a.ordinal_position ) AS RNUM
   # , A.TABLE_SCHEMA /*
   # , IF( A.ORDINAL_POSITION = 1
   #     , A.TABLE_SCHEMA
   #     , '') TABLE_SCHEMA -- */
   # , A.TABLE_NAME /*
     , IF( A.ORDINAL_POSITION = 1
         , A.TABLE_NAME
         , '') TABLE_NAME -- */
   # , B.TABLE_COMMENT /*
     , IF( A.ORDINAL_POSITION = 1
         , CASE WHEN B.TABLE_COMMENT != ''
                THEN B.TABLE_COMMENT
                ELSE '-------------' END
         , '') TABLE_COMMENT -- */
     , A.ORDINAL_POSITION AS NUM
     , A.COLUMN_NAME
     , IF( A.ORDINAL_POSITION = 1
         , CASE WHEN A.COLUMN_COMMENT != ''
                THEN A.COLUMN_COMMENT
                ELSE '--------------' END
         , A.COLUMN_COMMENT
         )   COLUMN_COMMENT
     , UPPER(A.COLUMN_TYPE) AS COLUMN_TYPE
     , CASE WHEN A.IS_NULLABLE = 'NO'
            THEN 'N' ELSE ''
       END    AS IS_NULL
     , CASE WHEN A.COLUMN_DEFAULT IS NULL
            THEN '' ELSE A.COLUMN_DEFAULT
       END    AS COLUMN_DEFAULT
     , CASE WHEN A.COLUMN_KEY = 'PRI'
            THEN 'PK' ELSE ''
       END    AS PRIMARY_KEY
     , CASE WHEN C.COLUMN_NAME IS NOT NULL
            THEN 'FK' ELSE ''
       END    AS FOREIGN_KEY
     , A.EXTRA
  FROM information_schema.COLUMNS A
  JOIN information_schema.TABLES  B
    ON A.TABLE_SCHEMA = B.TABLE_SCHEMA
   AND A.TABLE_NAME   = B.TABLE_NAME
   AND A.TABLE_SCHEMA NOT REGEXP '^sys|^mysql|^petra|schema$'
  LEFT OUTER
  JOIN ( SELECT DISTINCT
                TABLE_SCHEMA
              , TABLE_NAME
              , COLUMN_NAME
           FROM information_schema.KEY_COLUMN_USAGE
          WHERE CONSTRAINT_NAME NOT REGEXP '^PRIMARY'
            AND ORDINAL_POSITION  = 1
       ) C
    ON A.TABLE_SCHEMA = C.TABLE_SCHEMA
   AND A.TABLE_NAME   = C.TABLE_NAME
   AND A.COLUMN_NAME  = C.COLUMN_NAME
 WHERE A.TABLE_SCHEMA REGEXP '^maas'
   AND A.TABLE_NAME   REGEXP '^tb'
 ORDER BY A.TABLE_SCHEMA
        , A.TABLE_NAME
        , A.ORDINAL_POSITION
#LIMIT 50
;

SELECT a.table_schema
     , CASE WHEN a.seq_in_index = 1
            THEN t.table_comment
            ELSE ''
       END    AS table_comment
     , CASE WHEN a.seq_in_index = 1
            THEN a.table_name
            ELSE ''
       END    AS table_name
     , CASE WHEN a.seq_in_index = 1
            THEN a.index_name
            ELSE ''
       END    AS index_name
     # RPAD(a.index_name, 25, ' ') AS index_name
     , a.seq_in_index
     , a.column_name
     , UPPER(c.column_type) AS column_type
     , c.column_comment
     # RPAD(a.column_name, 25, ' ') AS column_name
     # a.cardinality
     # LPAD(FORMAT(a.cardinality, 0), 7, ' ') AS cardinality
     # index_type
    -- SELECT *
  FROM information_schema.STATISTICS a
  JOIN information_schema.TABLES     t
    ON t.table_schema = a.table_schema
   AND t.table_name   = a.table_name
   AND t.table_type   = 'BASE TABLE'
  JOIN information_schema.COLUMNS c
    ON c.table_schema = a.table_schema
   AND c.table_name   = a.table_name
   AND c.column_name  = a.column_name
 WHERE a.table_schema NOT REGEXP '^sys|^mysql|^petra|schema$'
   AND a.table_schema     REGEXP '^maas'
   AND a.table_name       REGEXP '^tb'
 ORDER BY a.table_schema
        , a.table_name
        , CASE WHEN a.index_name = 'PRIMARY'
               THEN 1 ELSE 2 END
        , a.index_name
        , a.seq_in_index
;

WITH table_list AS
(
    SELECT row_number() over( ORDER BY table_name ) as rnum
         , table_name
        -- SELECT *
      FROM information_schema.tables
     WHERE table_type   REGEXP 'TABLE$'
       AND table_schema REGEXP '^maas'
       AND table_name   REGEXP '^tb'
     ORDER BY table_name
     #LIMIT 10
)
SELECT /*+ SET_VAR(group_concat_max_len=50240) */
       CONCAT(GROUP_CONCAT( CONCAT( "SELECT CONCAT('"
                                  , LPAD(rnum, 3, '0')
                                  , "', ' "
                                  , RPAD(table_name, 10, ' ')
                                  , " = (', LPAD(FORMAT(count(*), 0), 8, ' '), ')') table_cnt FROM "
                                  , table_name
                                  )
                            ORDER BY table_name
                            SEPARATOR ' UNION ALL\n'
                          )
             )
  INTO @sql
  FROM table_list
;

PREPARE s FROM @sql ;
EXECUTE s;
DEALLOCATE PREPARE s;


SELECT table_schema
     , table_name
     , index_name
     , group_concat(column_name ORDER BY seq_in_index separator ', ') AS column_names
     # group_concat(column_name)                                     AS con_1
     # group_concat(column_name ORDER BY column_name DESC)           AS con_2
     # group_concat(DISTINCT column_name ORDER BY column_name DESC)  AS con_3
  FROM information_schema.STATISTICS
 WHERE table_schema NOT REGEXP '^sys|^mysql|^petra|schema$'
   AND table_schema     REGEXP '^maas|^mspdb'
   AND index_name   NOT REGEXP '^PRIMARY'
   AND table_name       REGEXP '^t'
 GROUP BY table_schema
        , table_name
        , index_name
 ORDER BY table_schema
        , table_name
        , CASE WHEN index_name = 'PRIMARY'
               THEN 1 ELSE 2 END
        , index_name
;


SELECT LPAD(row_number() over(), 3, '0') rnum
     , table_name AS 'TableName'
     , LPAD(FORMAT(SUM(table_rows), 0), 8, ' ') tableCnt
     , CONCAT(ROUND(SUM(table_rows) / 1000000, 2), 'M') rws
     , ROUND(SUM(data_length + index_length) / (1024*1024), 2) AS 'All(MB)'
     , ROUND(SUM(data_length) / (1024 * 1024), 2)  AS 'Data(MB)'
     , ROUND(SUM(index_length) / (1024 * 1024), 2) AS 'Index(MB)'
     , ROUND(SUM(data_free) / 1024 / 1024, 1)      AS 'Free(MB)'
  FROM information_schema.tables
 WHERE table_schema = SCHEMA()
   AND table_name REGEXP '^tb'
 GROUP BY table_name
 ORDER BY 5 DESC
;


SELECT B.TABLE_SCHEMA
     , B.TABLE_NAME
     , B.CONSTRAINT_NAME
     , GROUP_CONCAT(B.COLUMN_NAME
                    ORDER BY B.ORDINAL_POSITION) AS COLUMN_NAME
     , CASE WHEN B.REFERENCED_TABLE_SCHEMA IS NULL
            THEN '' ELSE B.REFERENCED_TABLE_SCHEMA
       END    AS REFERENCED_TABLE_SCHEMA
     , CASE WHEN B.REFERENCED_TABLE_NAME IS NULL
            THEN '' ELSE B.REFERENCED_TABLE_NAME
       END    AS REFERENCED_TABLE_NAME
     , CASE WHEN GROUP_CONCAT(B.REFERENCED_COLUMN_NAME
                              ORDER BY B.ORDINAL_POSITION) IS NULL
            THEN '' ELSE GROUP_CONCAT(B.REFERENCED_COLUMN_NAME
                                      ORDER BY B.ORDINAL_POSITION)
       END    AS REFERENCED_COLUMN_NAME
  FROM information_schema.KEY_COLUMN_USAGE B
 WHERE EXISTS ( SELECT 'O'
                  FROM information_schema.TABLE_CONSTRAINTS A
                 WHERE A.CONSTRAINT_TYPE  REGEXP '^FOREIGN|^PRIMARY'
                   AND A.TABLE_SCHEMA NOT REGEXP '^sys|^mysql|^petra|schema$'
                   AND A.TABLE_SCHEMA     REGEXP '^maas'
                   AND A.TABLE_NAME       REGEXP '^tb'
                   AND A.TABLE_SCHEMA    = B.TABLE_SCHEMA
                   AND A.TABLE_NAME      = B.TABLE_NAME
                   AND A.CONSTRAINT_NAME = B.CONSTRAINT_NAME
              )
 GROUP BY B.TABLE_SCHEMA
        , B.TABLE_NAME
        , B.CONSTRAINT_NAME
        , B.REFERENCED_TABLE_SCHEMA
        , B.REFERENCED_TABLE_NAME
 ORDER BY B.TABLE_SCHEMA
        , B.TABLE_NAME
        , CASE B.CONSTRAINT_NAME
               WHEN 'PRIMARY'
               THEN 1 ELSE 2 END
        , B.CONSTRAINT_NAME
;
